# Backend API Scaffold Framework 完整指南

## 📖 目录

1. [框架概述](#框架概述)
2. [技术架构](#技术架构)
3. [核心功能特性](#核心功能特性)
4. [项目结构详解](#项目结构详解)
5. [快速开始](#快速开始)
6. [新功能开发指南](#新功能开发指南)
7. [最佳实践](#最佳实践)
8. [部署指南](#部署指南)
9. [常见问题](#常见问题)

---

## 框架概述

### 🎯 项目定位

**Backend API Scaffold** 是一个完整的后端API服务脚手架框架，基于 Node.js + Express + MySQL 技术栈构建。它专门设计用于快速搭建双端API服务，同时支持**小程序端**和**后台管理端**的数据需求。

### 🌟 核心价值

- **开箱即用**: 完整的认证、权限、用户管理系统
- **双端支持**: 一套后端同时服务C端和B端需求
- **生产就绪**: 完善的安全防护、日志系统、错误处理
- **高扩展性**: 清晰的分层架构，易于添加新功能
- **测试完备**: 完整的测试框架和示例
- **文档齐全**: 详细的API文档和开发指南

### 📊 适用场景

- ✅ 小程序项目后端API
- ✅ 移动APP后端服务
- ✅ 管理后台系统
- ✅ 中小型Web应用后端
- ✅ 快速原型开发
- ✅ 学习现代Node.js开发实践

---

## 技术架构

### 🏗️ 整体架构

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   小程序端      │    │   管理后台      │    │   移动APP       │
│   (C端用户)     │    │   (B端管理员)   │    │   (用户端)      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
          │                       │                       │
          └───────────────────────┼───────────────────────┘
                                  │
                    ┌─────────────────────────┐
                    │    API Gateway Layer    │
                    │   (统一接口入口)        │
                    └─────────────────────────┘
                                  │
          ┌───────────────────────┼───────────────────────┐
          │                       │                       │
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   /api/v1/*     │    │  /api/admin/*   │    │   其他版本API   │
│   (小程序API)   │    │  (管理员API)    │    │   (扩展接口)    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
          │                       │                       │
          └───────────────────────┼───────────────────────┘
                                  │
                    ┌─────────────────────────┐
                    │   Business Logic Layer  │
                    │   (业务逻辑层)          │
                    │  Controllers/Services   │
                    └─────────────────────────┘
                                  │
                    ┌─────────────────────────┐
                    │    Data Access Layer    │
                    │   (数据访问层)          │
                    │   Models/Database       │
                    └─────────────────────────┘
                                  │
                    ┌─────────────────────────┐
                    │     MySQL Database      │
                    │   (关系型数据库)        │
                    └─────────────────────────┘
```

### 🛠️ 技术栈

| 分层 | 技术选型 | 说明 |
|------|----------|------|
| **运行环境** | Node.js 16+ | JavaScript 运行时 |
| **Web框架** | Express.js | 轻量级、高性能的Web框架 |
| **数据库** | MySQL 5.7+ | 关系型数据库 |
| **ORM** | Sequelize | 强大的Node.js ORM |
| **认证** | JWT + bcryptjs | JSON Web Token + 密码加密 |
| **日志** | Winston | 分级日志系统 |
| **验证** | express-validator | 数据验证中间件 |
| **安全** | Helmet + CORS | HTTP安全头 + 跨域支持 |
| **测试** | Jest + Supertest | 单元测试 + API测试 |
| **文档** | JSDoc + Markdown | 代码文档 + API文档 |

### 🔐 安全架构

```
┌─────────────────────────────────────────────────────────────┐
│                        安全防护层                          │
├─────────────────────────────────────────────────────────────┤
│ • Helmet (HTTP安全头)                                       │
│ • CORS (跨域资源共享)                                       │
│ • Rate Limiting (请求频率限制)                              │
│ • Input Validation (输入验证)                               │
│ • SQL Injection Prevention (SQL注入防护)                   │
└─────────────────────────────────────────────────────────────┘
                                  │
┌─────────────────────────────────────────────────────────────┐
│                        认证授权层                          │
├─────────────────────────────────────────────────────────────┤
│ • JWT Token Authentication (JWT令牌认证)                   │
│ • Role-Based Access Control (基于角色的访问控制)           │
│ • Permission Level Control (权限等级控制)                  │
│ • Account Lockout Protection (账户锁定保护)                │
│ • Session Management (会话管理)                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 核心功能特性

### 👤 用户认证系统

#### 🔑 多种登录方式
- **用户名登录**: 支持用户名/密码登录
- **邮箱登录**: 支持邮箱/密码登录  
- **手机号登录**: 支持手机号/密码登录
- **小程序登录**: 微信小程序 OAuth 登录
- **Token刷新**: 自动续期机制

#### 🔒 密码安全策略
```javascript
// 密码策略配置 (config/auth.js)
password: {
  minLength: 6,           // 最小长度
  maxLength: 128,         // 最大长度
  requireNumbers: false,  // 是否要求数字
  requireLowercase: false,// 是否要求小写字母
  requireUppercase: false,// 是否要求大写字母
  requireSymbols: false,  // 是否要求特殊符号
  saltRounds: 12         // bcrypt 加密轮次
}
```

#### 🛡️ 账户保护机制
- **登录失败锁定**: 连续失败5次锁定15分钟
- **JWT双令牌**: 访问令牌(7天) + 刷新令牌(30天)
- **会话管理**: 单用户最多5个并发会话
- **IP地址记录**: 记录登录IP和时间

### 🎭 权限管理系统

#### 📊 5级权限体系
```javascript
// 权限等级 (数字越大权限越高)
roleHierarchy: {
  guest: 0,        // 游客
  user: 10,        // 普通用户  
  moderator: 20,   // 版主
  admin: 30,       // 管理员
  super_admin: 99  // 超级管理员
}
```

#### 🔐 访问控制机制
- **角色继承**: 高等级角色自动包含低等级权限
- **资源所有权**: 用户只能访问自己的资源
- **管理员特权**: 管理员可访问所有资源
- **细粒度控制**: 支持接口级权限控制

### 🌐 双端API设计

#### 📱 小程序端API (`/api/v1/`)
面向C端用户，提供基础业务功能：
```javascript
// 用户功能
GET    /api/v1/user/profile        // 获取用户资料
PUT    /api/v1/user/profile        // 更新用户资料
GET    /api/v1/user/search         // 搜索用户

// 认证功能  
POST   /api/v1/auth/register       // 用户注册
POST   /api/v1/auth/login          // 用户登录
POST   /api/v1/auth/refresh        // 刷新Token
POST   /api/v1/auth/logout         // 用户登出

// 小程序专用
POST   /api/v1/miniprogram/login   // 小程序登录
GET    /api/v1/miniprogram/config  // 获取配置
```

#### 🏢 管理端API (`/api/admin/`)
面向B端管理员，提供管理功能：
```javascript
// 用户管理
GET    /api/admin/users            // 获取用户列表
GET    /api/admin/users/stats      // 用户统计
PUT    /api/admin/users/:id        // 更新用户
DELETE /api/admin/users/:id        // 删除用户
POST   /api/admin/users/batch      // 批量操作

// 系统管理
GET    /api/admin/system/info      // 系统信息
GET    /api/admin/system/health    // 健康检查
```

### 📊 数据库设计

#### 👤 用户表结构
```sql
CREATE TABLE users (
  id INT PRIMARY KEY AUTO_INCREMENT,
  username VARCHAR(50) UNIQUE NOT NULL,
  email VARCHAR(100) UNIQUE,
  phone VARCHAR(20) UNIQUE,
  password VARCHAR(255),
  nickname VARCHAR(50),
  avatar TEXT,
  gender ENUM('male', 'female', 'unknown') DEFAULT 'unknown',
  birthday DATE,
  role ENUM('super_admin', 'admin', 'moderator', 'user', 'guest') DEFAULT 'user',
  status ENUM('active', 'inactive', 'banned', 'pending') DEFAULT 'active',
  
  -- 小程序字段
  openid VARCHAR(100) UNIQUE,
  unionid VARCHAR(100) UNIQUE,
  
  -- 安全字段
  email_verified BOOLEAN DEFAULT FALSE,
  phone_verified BOOLEAN DEFAULT FALSE,
  login_attempts INT DEFAULT 0,
  locked_until DATETIME,
  last_login_at DATETIME,
  last_login_ip VARCHAR(45),
  
  -- 时间戳
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at DATETIME
);
```

### 📝 日志系统

#### 📈 分级日志记录
```javascript
// 日志级别
logger.error('系统错误');   // 错误日志
logger.warn('安全警告');    // 警告日志  
logger.info('业务操作');    // 信息日志
logger.debug('调试信息');   // 调试日志
```

#### 📋 日志分类
- **访问日志**: 记录所有API请求
- **业务日志**: 记录用户操作行为
- **安全日志**: 记录认证和权限事件
- **错误日志**: 记录系统异常和错误
- **慢请求日志**: 记录响应时间超过阈值的请求

### 🧪 测试框架

#### ✅ 测试覆盖
- **单元测试**: 工具函数、中间件、服务层
- **集成测试**: API端点完整流程
- **认证测试**: JWT和权限控制
- **错误测试**: 异常处理和边界情况

#### 🎯 测试命令
```bash
npm test                    # 运行所有测试
npm run test:coverage       # 生成覆盖率报告
npm run test:unit          # 单元测试
npm run test:integration   # 集成测试
npm run test:watch         # 监听模式
```

---

## 项目结构详解

```
backend-api-scaffold/
├── 📁 config/                    # 配置文件目录
│   ├── app.js                   # 应用配置 (CORS、上传、分页等)
│   ├── auth.js                  # 认证配置 (JWT、密码策略、权限等)
│   └── database.js              # 数据库配置 (开发/测试/生产环境)
│
├── 📁 src/                       # 源代码目录
│   ├── 📁 controllers/          # 控制器层 (处理HTTP请求响应)
│   │   ├── auth.js             # 认证控制器 (登录、注册、登出等)
│   │   └── user.js             # 用户控制器 (用户管理功能)
│   │
│   ├── 📁 middleware/           # 中间件目录
│   │   ├── auth.js             # 认证中间件 (JWT验证、权限控制)
│   │   ├── error.js            # 错误处理中间件
│   │   └── logger.js           # 日志中间件
│   │
│   ├── 📁 models/               # 数据模型目录
│   │   └── User.js             # 用户模型 (Sequelize模型定义)
│   │
│   ├── 📁 routes/               # 路由定义目录
│   │   ├── index.js            # 主路由入口
│   │   └── 📁 api/              # API路由
│   │       ├── 📁 v1/           # v1版本API (小程序端)
│   │       │   ├── index.js    # v1路由入口
│   │       │   ├── auth.js     # 认证路由
│   │       │   ├── user.js     # 用户路由
│   │       │   └── miniprogram.js # 小程序专用路由
│   │       └── 📁 admin/        # 管理员API
│   │           ├── index.js    # 管理员路由入口
│   │           ├── auth.js     # 管理员认证路由
│   │           └── user.js     # 用户管理路由
│   │
│   ├── 📁 services/             # 业务逻辑层
│   │   ├── authService.js      # 认证服务 (业务逻辑实现)
│   │   └── userService.js      # 用户服务 (用户相关业务逻辑)
│   │
│   ├── 📁 utils/                # 工具函数目录
│   │   ├── encrypt.js          # 加密工具 (JWT、bcrypt、Hash等)
│   │   ├── logger.js           # 日志工具 (Winston配置)
│   │   ├── response.js         # 响应工具 (统一API响应格式)
│   │   └── validate.js         # 验证工具 (数据验证规则)
│   │
│   └── 📁 database/             # 数据库相关
│       ├── connection.js       # 数据库连接配置
│       ├── migrate.js          # 数据库迁移脚本
│       └── seed.js             # 种子数据脚本
│
├── 📁 tests/                     # 测试目录
│   ├── 📁 helpers/              # 测试辅助工具
│   ├── 📁 unit/                 # 单元测试
│   ├── 📁 integration/          # 集成测试
│   └── setup.js                # 测试环境配置
│
├── 📁 docs/                      # 文档目录
│   ├── API.md                  # API接口文档
│   ├── DEVELOPMENT.md          # 开发指南
│   └── FRAMEWORK_GUIDE.md      # 本文档
│
├── 📁 logs/                      # 日志文件目录 (自动生成)
├── 📁 uploads/                   # 文件上传目录
├── app.js                       # 应用入口文件
├── package.json                 # 项目配置和依赖
├── jest.config.js              # Jest测试配置
├── .env.example                # 环境变量模板
├── .gitignore                  # Git忽略文件
└── README.md                   # 项目说明
```

### 🔧 核心文件说明

#### 📋 `app.js` - 应用入口
```javascript
// 主要功能:
// 1. 加载环境变量和配置
// 2. 设置安全中间件 (Helmet, CORS)
// 3. 配置请求限制和解析
// 4. 注册路由和错误处理
// 5. 数据库连接和服务启动
```

#### 🛠️ `config/` - 配置管理
- **模块化配置**: 按功能分离配置文件
- **环境区分**: 开发/测试/生产环境配置
- **类型安全**: 配置验证和默认值

#### 🎮 `controllers/` - 控制器层
- **职责单一**: 只处理HTTP请求响应
- **参数验证**: 使用express-validator验证
- **错误处理**: 统一错误处理机制
- **响应格式**: 使用response工具统一格式

#### 🔐 `middleware/` - 中间件层
- **认证中间件**: JWT验证和用户信息注入
- **权限中间件**: 角色和权限检查
- **日志中间件**: 请求日志记录
- **错误中间件**: 统一错误处理

#### 💾 `models/` - 数据模型层
- **Sequelize模型**: ORM对象关系映射
- **数据验证**: 模型级别的数据验证
- **关联关系**: 模型间的关联定义
- **钩子函数**: 数据操作的生命周期钩子

#### 🛣️ `routes/` - 路由层
- **分层路由**: 按版本和功能分组
- **版本控制**: 支持多API版本并存
- **权限控制**: 路由级别的权限验证
- **参数验证**: 路由参数验证

#### 🏪 `services/` - 业务逻辑层
- **业务封装**: 复杂业务逻辑的实现
- **数据处理**: 业务数据的转换和处理
- **第三方集成**: 外部服务的调用封装
- **事务管理**: 数据库事务的管理

---

## 快速开始

### 🚀 环境准备

#### 系统要求
- **Node.js**: >= 16.0.0
- **MySQL**: >= 5.7 或 >= 8.0
- **npm**: >= 7.0.0

#### 开发工具推荐
- **代码编辑器**: VS Code / WebStorm
- **数据库工具**: MySQL Workbench / DBeaver
- **API测试**: Postman / Insomnia
- **版本控制**: Git

### 📦 安装配置

#### 1. 项目初始化
```bash
# 克隆项目
git clone <your-repo-url>
cd backend-api-scaffold

# 安装依赖
npm install
```

#### 2. 环境配置
```bash
# 复制环境变量模板
cp .env.example .env

# 编辑环境变量 (根据你的实际环境调整)
vim .env
```

#### 3. `.env` 配置说明
```env
# 应用配置
NODE_ENV=development              # 环境: development/test/production
PORT=3000                        # 服务端口
APP_SECRET=your-secret-key       # 应用密钥

# 数据库配置
DB_HOST=localhost                # 数据库主机
DB_PORT=3306                     # 数据库端口
DB_NAME=scaffold_db              # 数据库名
DB_USER=root                     # 数据库用户名
DB_PASSWORD=your_password        # 数据库密码

# JWT配置
JWT_SECRET=your-jwt-secret       # JWT密钥 (生产环境必须使用强密钥)
JWT_EXPIRES_IN=7d               # 访问令牌过期时间
JWT_REFRESH_EXPIRES_IN=30d      # 刷新令牌过期时间

# 小程序配置 (可选)
MINIPROGRAM_APP_ID=wx_app_id     # 微信小程序AppID
MINIPROGRAM_APP_SECRET=wx_secret # 微信小程序Secret

# 文件上传配置
UPLOAD_DIR=uploads               # 上传目录
MAX_FILE_SIZE=5MB               # 最大文件大小

# 日志配置
LOG_LEVEL=info                  # 日志级别: debug/info/warn/error
```

#### 4. 数据库初始化
```bash
# 创建数据库 (MySQL命令行)
mysql -u root -p
CREATE DATABASE scaffold_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

# 运行数据库迁移
npm run migrate

# 创建初始数据 (可选)
npm run seed
```

#### 5. 启动应用
```bash
# 开发模式 (支持热重载)
npm run dev

# 生产模式
npm start
```

### ✅ 验证安装

访问以下URL验证安装成功：

- **健康检查**: http://localhost:3000/health
- **API信息**: http://localhost:3000/
- **小程序API**: http://localhost:3000/api/v1/
- **管理员API**: http://localhost:3000/api/admin/

#### 默认测试账户
```javascript
// 超级管理员
username: admin
password: admin123456

// 管理员  
username: manager
password: manager123456

// 测试用户
username: user001
password: user123456
```

---

## 新功能开发指南

这部分将详细说明如何基于现有框架开发新功能。我们以开发一个**文章管理功能**为例。

### 📝 开发流程概览

```
1. 需求分析 → 2. 数据模型设计 → 3. API接口设计 → 4. 数据库迁移 
     ↓
8. 测试编写 ← 7. 路由配置 ← 6. 控制器实现 ← 5. 服务层实现
     ↓  
9. 文档更新 → 10. 部署上线
```

### 🎯 需求分析

#### 功能需求
我们要开发一个文章管理系统，包含以下功能：

**C端用户功能** (`/api/v1/articles/`):
- 查看文章列表 (支持分页、分类筛选)
- 查看文章详情
- 搜索文章
- 发布文章 (需要登录)
- 编辑自己的文章
- 删除自己的文章

**B端管理员功能** (`/api/admin/articles/`):
- 管理所有文章 (增删改查)
- 文章审核 (发布/下架)
- 文章统计 (总数、分类统计)
- 批量操作文章

#### 数据结构设计
```javascript
// 文章数据结构
{
  id: 1,
  title: "文章标题",
  content: "文章内容",
  summary: "文章摘要", 
  cover_image: "封面图片URL",
  category: "技术分类",
  tags: ["Node.js", "Express"],
  status: "published", // draft/published/archived
  view_count: 100,
  like_count: 50,
  author_id: 1,
  published_at: "2024-01-01T00:00:00Z",
  created_at: "2024-01-01T00:00:00Z",
  updated_at: "2024-01-01T00:00:00Z"
}
```

### 📊 Step 1: 数据模型设计

#### 创建文章模型
```bash
# 创建模型文件
touch src/models/Article.js
```

```javascript
// src/models/Article.js
const { DataTypes } = require('sequelize');
const { sequelize } = require('../database/connection');

const Article = sequelize.define('Article', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    comment: '文章ID'
  },
  
  title: {
    type: DataTypes.STRING(200),
    allowNull: false,
    comment: '文章标题',
    validate: {
      notEmpty: true,
      len: [1, 200]
    }
  },
  
  content: {
    type: DataTypes.TEXT('long'),
    allowNull: false,
    comment: '文章内容'
  },
  
  summary: {
    type: DataTypes.TEXT,
    allowNull: true,
    comment: '文章摘要',
    validate: {
      len: [0, 500]
    }
  },
  
  cover_image: {
    type: DataTypes.TEXT,
    allowNull: true,
    comment: '封面图片URL'
  },
  
  category: {
    type: DataTypes.STRING(50),
    allowNull: false,
    defaultValue: 'general',
    comment: '文章分类'
  },
  
  tags: {
    type: DataTypes.JSON,
    allowNull: true,
    defaultValue: [],
    comment: '文章标签'
  },
  
  status: {
    type: DataTypes.ENUM('draft', 'published', 'archived'),
    allowNull: false,
    defaultValue: 'draft',
    comment: '文章状态'
  },
  
  view_count: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0,
    comment: '浏览次数'
  },
  
  like_count: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0,
    comment: '点赞次数'
  },
  
  author_id: {
    type: DataTypes.INTEGER,
    allowNull: false,
    comment: '作者ID',
    references: {
      model: 'users',
      key: 'id'
    }
  },
  
  published_at: {
    type: DataTypes.DATE,
    allowNull: true,
    comment: '发布时间'
  },
  
  created_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    comment: '创建时间'
  },
  
  updated_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    comment: '更新时间'
  },
  
  deleted_at: {
    type: DataTypes.DATE,
    allowNull: true,
    comment: '删除时间'
  }
}, {
  tableName: 'articles',
  timestamps: true,
  paranoid: true,
  underscored: true,
  indexes: [
    {
      name: 'idx_author_id',
      fields: ['author_id']
    },
    {
      name: 'idx_category',
      fields: ['category']
    },
    {
      name: 'idx_status',
      fields: ['status']
    },
    {
      name: 'idx_published_at',
      fields: ['published_at']
    }
  ]
});

// 定义关联关系
Article.associate = function(models) {
  // 文章属于用户
  Article.belongsTo(models.User, {
    foreignKey: 'author_id',
    as: 'author'
  });
};

// 实例方法
Article.prototype.toJSON = function() {
  const values = { ...this.get() };
  return values;
};

// 增加浏览次数
Article.prototype.incrementViewCount = async function() {
  return this.increment('view_count');
};

// 增加点赞次数
Article.prototype.incrementLikeCount = async function() {
  return this.increment('like_count');
};

module.exports = Article;
```

#### 更新用户模型关联
```javascript
// src/models/User.js (在文件末尾添加)

// 添加关联关系
User.associate = function(models) {
  // 用户有多篇文章
  User.hasMany(models.Article, {
    foreignKey: 'author_id',
    as: 'articles'
  });
};
```

### 🗄️ Step 2: 数据库迁移

#### 更新迁移脚本
```javascript
// src/database/migrate.js (添加 Article 模型导入)
require('dotenv').config();
const { sequelize } = require('./connection');

// 导入所有模型
const User = require('../models/User');
const Article = require('../models/Article'); // 新增

// 建立模型关联
const models = { User, Article };
Object.keys(models).forEach(key => {
  if ('associate' in models[key]) {
    models[key].associate(models);
  }
});

// 其余代码保持不变...
```

#### 运行迁移
```bash
npm run migrate
```

### 🏪 Step 3: 服务层实现

#### 创建文章服务
```bash
touch src/services/articleService.js
```

```javascript
// src/services/articleService.js
const Article = require('../models/Article');
const User = require('../models/User');
const { logBusinessAction, logDatabaseOperation } = require('../utils/logger');
const { Op } = require('sequelize');
const appConfig = require('../../config/app');

/**
 * 获取文章列表服务
 */
async function getArticleList(filters = {}, pagination = {}) {
  const {
    search,
    category,
    status,
    author_id,
    startDate,
    endDate
  } = filters;
  
  const {
    page = appConfig.pagination.defaultPage,
    limit = appConfig.pagination.defaultLimit,
    sort = 'published_at:desc'
  } = pagination;
  
  // 构建查询条件
  const whereConditions = {};
  
  if (search) {
    whereConditions[Op.or] = [
      { title: { [Op.like]: `%${search}%` } },
      { summary: { [Op.like]: `%${search}%` } },
      { content: { [Op.like]: `%${search}%` } }
    ];
  }
  
  if (category) {
    whereConditions.category = category;
  }
  
  if (status) {
    whereConditions.status = status;
  } else {
    // 默认只显示已发布的文章
    whereConditions.status = 'published';
  }
  
  if (author_id) {
    whereConditions.author_id = author_id;
  }
  
  if (startDate || endDate) {
    whereConditions.published_at = {};
    if (startDate) whereConditions.published_at[Op.gte] = new Date(startDate);
    if (endDate) whereConditions.published_at[Op.lte] = new Date(endDate);
  }
  
  // 构建排序条件
  const [sortField, sortOrder] = sort.split(':');
  const order = [[sortField, sortOrder.toUpperCase()]];
  
  // 计算偏移量
  const offset = (page - 1) * limit;
  
  // 查询文章列表
  const { count, rows: articles } = await Article.findAndCountAll({
    where: whereConditions,
    include: [{
      model: User,
      as: 'author',
      attributes: ['id', 'username', 'nickname', 'avatar']
    }],
    order,
    limit: parseInt(limit),
    offset: parseInt(offset)
  });
  
  return {
    articles,
    pagination: {
      total: count,
      page: parseInt(page),
      limit: parseInt(limit)
    }
  };
}

/**
 * 获取文章详情服务
 */
async function getArticleById(articleId, includeDeleted = false) {
  const options = {
    include: [{
      model: User,
      as: 'author',
      attributes: ['id', 'username', 'nickname', 'avatar']
    }]
  };
  
  if (includeDeleted) {
    options.paranoid = false;
  }
  
  const article = await Article.findByPk(articleId, options);
  
  if (!article) {
    throw new Error('文章不存在');
  }
  
  // 增加浏览次数
  await article.incrementViewCount();
  
  return article;
}

/**
 * 创建文章服务
 */
async function createArticle(articleData, author) {
  const {
    title,
    content,
    summary,
    cover_image,
    category,
    tags,
    status = 'draft'
  } = articleData;
  
  const article = await Article.create({
    title,
    content,
    summary,
    cover_image,
    category,
    tags,
    status,
    author_id: author.id,
    published_at: status === 'published' ? new Date() : null
  });
  
  logBusinessAction('article_created', {
    articleId: article.id,
    title: article.title,
    status: article.status
  }, author);
  
  return article;
}

/**
 * 更新文章服务
 */
async function updateArticle(articleId, updateData, operator) {
  const article = await Article.findByPk(articleId);
  
  if (!article) {
    throw new Error('文章不存在');
  }
  
  // 检查权限 (作者或管理员可以编辑)
  if (article.author_id !== operator.id && 
      !['admin', 'super_admin'].includes(operator.role)) {
    throw new Error('没有权限编辑此文章');
  }
  
  // 过滤允许更新的字段
  const allowedFields = ['title', 'content', 'summary', 'cover_image', 'category', 'tags', 'status'];
  const filteredData = {};
  
  Object.keys(updateData).forEach(key => {
    if (allowedFields.includes(key) && updateData[key] !== undefined) {
      filteredData[key] = updateData[key];
    }
  });
  
  // 如果状态变为已发布，设置发布时间
  if (filteredData.status === 'published' && article.status !== 'published') {
    filteredData.published_at = new Date();
  }
  
  const updatedArticle = await article.update(filteredData);
  
  logBusinessAction('article_updated', {
    articleId,
    updatedFields: Object.keys(filteredData)
  }, operator);
  
  return updatedArticle;
}

/**
 * 删除文章服务
 */
async function deleteArticle(articleId, operator) {
  const article = await Article.findByPk(articleId);
  
  if (!article) {
    throw new Error('文章不存在');
  }
  
  // 检查权限 (作者或管理员可以删除)
  if (article.author_id !== operator.id && 
      !['admin', 'super_admin'].includes(operator.role)) {
    throw new Error('没有权限删除此文章');
  }
  
  await article.destroy();
  
  logBusinessAction('article_deleted', { articleId }, operator);
  
  return true;
}

/**
 * 搜索文章服务
 */
async function searchArticles(keyword, limit = 10) {
  const articles = await Article.findAll({
    where: {
      [Op.or]: [
        { title: { [Op.like]: `%${keyword}%` } },
        { summary: { [Op.like]: `%${keyword}%` } }
      ],
      status: 'published'
    },
    include: [{
      model: User,
      as: 'author',
      attributes: ['id', 'username', 'nickname', 'avatar']
    }],
    attributes: ['id', 'title', 'summary', 'cover_image', 'category', 'published_at'],
    limit: parseInt(limit),
    order: [['published_at', 'DESC']]
  });
  
  return articles;
}

/**
 * 获取文章统计信息
 */
async function getArticleStats() {
  const totalArticles = await Article.count();
  const publishedArticles = await Article.count({ where: { status: 'published' } });
  const draftArticles = await Article.count({ where: { status: 'draft' } });
  const todayArticles = await Article.count({
    where: {
      created_at: {
        [Op.gte]: new Date(new Date().setHours(0, 0, 0, 0))
      }
    }
  });
  
  // 按分类统计
  const categoryStats = await Article.findAll({
    attributes: [
      'category',
      [Article.sequelize.fn('COUNT', Article.sequelize.col('id')), 'count']
    ],
    where: { status: 'published' },
    group: ['category']
  });
  
  return {
    total: totalArticles,
    published: publishedArticles,
    draft: draftArticles,
    today: todayArticles,
    categoryDistribution: categoryStats.map(item => ({
      category: item.category,
      count: parseInt(item.get('count'))
    }))
  };
}

/**
 * 点赞文章服务
 */
async function likeArticle(articleId, userId) {
  const article = await Article.findByPk(articleId);
  
  if (!article) {
    throw new Error('文章不存在');
  }
  
  if (article.status !== 'published') {
    throw new Error('文章未发布，无法点赞');
  }
  
  await article.incrementLikeCount();
  
  logBusinessAction('article_liked', { 
    articleId, 
    userId 
  }, { id: userId });
  
  return article;
}

module.exports = {
  getArticleList,
  getArticleById,
  createArticle,
  updateArticle,
  deleteArticle,
  searchArticles,
  getArticleStats,
  likeArticle
};
```

### 🎮 Step 4: 控制器实现

#### 创建文章控制器
```bash
touch src/controllers/article.js
```

```javascript
// src/controllers/article.js
const articleService = require('../services/articleService');
const { success, error, paginated, asyncHandler } = require('../utils/response');
const { validationResult } = require('express-validator');

/**
 * @api {get} /api/v1/articles 获取文章列表
 * @apiName GetArticleList
 * @apiGroup Article
 * @apiVersion 1.0.0
 */
const getArticleList = asyncHandler(async (req, res) => {
  const result = await articleService.getArticleList(req.query, req.query);
  return paginated(res, result.articles, result.pagination, '获取文章列表成功');
});

/**
 * @api {get} /api/v1/articles/:id 获取文章详情
 * @apiName GetArticleDetail
 * @apiGroup Article
 * @apiVersion 1.0.0
 */
const getArticleDetail = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const article = await articleService.getArticleById(id);
  return success(res, article, '获取文章详情成功');
});

/**
 * @api {post} /api/v1/articles 创建文章
 * @apiName CreateArticle
 * @apiGroup Article
 * @apiVersion 1.0.0
 */
const createArticle = asyncHandler(async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return error(res, '数据验证失败', 422, errors.array());
  }

  const article = await articleService.createArticle(req.body, req.user);
  return success(res, article, '文章创建成功', 201);
});

/**
 * @api {put} /api/v1/articles/:id 更新文章
 * @apiName UpdateArticle
 * @apiGroup Article
 * @apiVersion 1.0.0
 */
const updateArticle = asyncHandler(async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return error(res, '数据验证失败', 422, errors.array());
  }

  const { id } = req.params;
  const article = await articleService.updateArticle(id, req.body, req.user);
  return success(res, article, '文章更新成功');
});

/**
 * @api {delete} /api/v1/articles/:id 删除文章
 * @apiName DeleteArticle
 * @apiGroup Article
 * @apiVersion 1.0.0
 */
const deleteArticle = asyncHandler(async (req, res) => {
  const { id } = req.params;
  await articleService.deleteArticle(id, req.user);
  return success(res, null, '文章删除成功');
});

/**
 * @api {get} /api/v1/articles/search 搜索文章
 * @apiName SearchArticles
 * @apiGroup Article
 * @apiVersion 1.0.0
 */
const searchArticles = asyncHandler(async (req, res) => {
  const { keyword, limit } = req.query;
  
  if (!keyword) {
    return error(res, '搜索关键词不能为空', 400);
  }

  const articles = await articleService.searchArticles(keyword, limit);
  return success(res, articles, '搜索文章成功');
});

/**
 * @api {post} /api/v1/articles/:id/like 点赞文章
 * @apiName LikeArticle
 * @apiGroup Article
 * @apiVersion 1.0.0
 */
const likeArticle = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const article = await articleService.likeArticle(id, req.user.id);
  return success(res, { like_count: article.like_count }, '点赞成功');
});

// 管理员功能控制器

/**
 * @api {get} /api/admin/articles 获取所有文章列表（管理员）
 * @apiName AdminGetArticleList
 * @apiGroup AdminArticle
 * @apiVersion 1.0.0
 */
const adminGetArticleList = asyncHandler(async (req, res) => {
  // 管理员可以查看所有状态的文章
  const filters = { ...req.query };
  delete filters.status; // 移除状态限制
  
  const result = await articleService.getArticleList(filters, req.query);
  return paginated(res, result.articles, result.pagination, '获取文章列表成功');
});

/**
 * @api {put} /api/admin/articles/:id 更新文章（管理员）
 * @apiName AdminUpdateArticle
 * @apiGroup AdminArticle
 * @apiVersion 1.0.0
 */
const adminUpdateArticle = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const article = await articleService.updateArticle(id, req.body, req.user);
  return success(res, article, '文章更新成功');
});

/**
 * @api {delete} /api/admin/articles/:id 删除文章（管理员）
 * @apiName AdminDeleteArticle
 * @apiGroup AdminArticle
 * @apiVersion 1.0.0
 */
const adminDeleteArticle = asyncHandler(async (req, res) => {
  const { id } = req.params;
  await articleService.deleteArticle(id, req.user);
  return success(res, null, '文章删除成功');
});

/**
 * @api {get} /api/admin/articles/stats 获取文章统计信息（管理员）
 * @apiName GetArticleStats
 * @apiGroup AdminArticle
 * @apiVersion 1.0.0
 */
const getArticleStats = asyncHandler(async (req, res) => {
  const stats = await articleService.getArticleStats();
  return success(res, stats, '获取文章统计成功');
});

module.exports = {
  // 普通用户功能
  getArticleList,
  getArticleDetail,
  createArticle,
  updateArticle,
  deleteArticle,
  searchArticles,
  likeArticle,
  
  // 管理员功能
  adminGetArticleList,
  adminUpdateArticle,
  adminDeleteArticle,
  getArticleStats
};
```

### ✅ Step 5: 数据验证

#### 添加文章验证规则
```javascript
// src/utils/validate.js (在文件末尾添加)

/**
 * 文章创建验证规则
 */
const createArticleValidation = [
  body('title')
    .isLength({ min: 1, max: 200 })
    .withMessage('文章标题长度必须在1-200个字符之间'),
  
  body('content')
    .notEmpty()
    .withMessage('文章内容不能为空'),
  
  body('summary')
    .optional()
    .isLength({ max: 500 })
    .withMessage('文章摘要不能超过500个字符'),
  
  body('cover_image')
    .optional()
    .isURL()
    .withMessage('封面图片必须是有效的URL'),
  
  body('category')
    .notEmpty()
    .withMessage('文章分类不能为空')
    .isLength({ max: 50 })
    .withMessage('文章分类不能超过50个字符'),
  
  body('tags')
    .optional()
    .isArray()
    .withMessage('文章标签必须是数组'),
  
  body('status')
    .optional()
    .isIn(['draft', 'published', 'archived'])
    .withMessage('文章状态只能是draft、published或archived')
];

/**
 * 文章更新验证规则
 */
const updateArticleValidation = [
  body('title')
    .optional()
    .isLength({ min: 1, max: 200 })
    .withMessage('文章标题长度必须在1-200个字符之间'),
  
  body('content')
    .optional()
    .notEmpty()
    .withMessage('文章内容不能为空'),
  
  body('summary')
    .optional()
    .isLength({ max: 500 })
    .withMessage('文章摘要不能超过500个字符'),
  
  body('cover_image')
    .optional()
    .isURL()
    .withMessage('封面图片必须是有效的URL'),
  
  body('category')
    .optional()
    .isLength({ max: 50 })
    .withMessage('文章分类不能超过50个字符'),
  
  body('tags')
    .optional()
    .isArray()
    .withMessage('文章标签必须是数组'),
  
  body('status')
    .optional()
    .isIn(['draft', 'published', 'archived'])
    .withMessage('文章状态只能是draft、published或archived')
];

// 导出验证规则
module.exports = {
  // ... 现有导出
  createArticleValidation,
  updateArticleValidation
};
```

### 🛣️ Step 6: 路由配置

#### 创建小程序端文章路由
```bash
touch src/routes/api/v1/article.js
```

```javascript
// src/routes/api/v1/article.js
const express = require('express');
const router = express.Router();

// 导入控制器
const articleController = require('../../../controllers/article');

// 导入中间件
const { authenticateToken, optionalAuth } = require('../../../middleware/auth');
const { 
  createArticleValidation,
  updateArticleValidation,
  idValidation,
  handleValidationErrors 
} = require('../../../utils/validate');

/**
 * 公开接口（无需认证）
 */

// 获取文章列表
router.get('/', articleController.getArticleList);

// 获取文章详情
router.get('/:id', 
  idValidation,
  handleValidationErrors,
  articleController.getArticleDetail
);

// 搜索文章
router.get('/search', articleController.searchArticles);

/**
 * 需要认证的接口
 */

// 创建文章
router.post('/', 
  authenticateToken,
  createArticleValidation,
  handleValidationErrors,
  articleController.createArticle
);

// 更新文章
router.put('/:id', 
  authenticateToken,
  idValidation,
  updateArticleValidation,
  handleValidationErrors,
  articleController.updateArticle
);

// 删除文章
router.delete('/:id', 
  authenticateToken,
  idValidation,
  handleValidationErrors,
  articleController.deleteArticle
);

// 点赞文章
router.post('/:id/like', 
  authenticateToken,
  idValidation,
  handleValidationErrors,
  articleController.likeArticle
);

module.exports = router;
```

#### 创建管理员文章路由
```bash
touch src/routes/api/admin/article.js
```

```javascript
// src/routes/api/admin/article.js
const express = require('express');
const router = express.Router();

// 导入控制器
const articleController = require('../../../controllers/article');

// 导入中间件
const { requireSuperAdmin } = require('../../../middleware/auth');
const { 
  updateArticleValidation,
  idValidation,
  paginationValidation,
  handleValidationErrors 
} = require('../../../utils/validate');

/**
 * 文章管理接口
 * 注意：这些接口已经在上级路由中应用了认证和管理员权限中间件
 */

// 获取文章统计信息
router.get('/stats', articleController.getArticleStats);

// 获取文章列表
router.get('/', 
  paginationValidation,
  handleValidationErrors,
  articleController.adminGetArticleList
);

// 获取指定文章详细信息
router.get('/:id', 
  idValidation,
  handleValidationErrors,
  articleController.getArticleDetail
);

// 更新文章信息
router.put('/:id', 
  idValidation,
  updateArticleValidation,
  handleValidationErrors,
  articleController.adminUpdateArticle
);

// 删除文章
router.delete('/:id', 
  idValidation,
  handleValidationErrors,
  articleController.adminDeleteArticle
);

module.exports = router;
```

#### 注册文章路由

```javascript
// src/routes/api/v1/index.js (添加文章路由)
const articleRoutes = require('./article');

// 注册子路由
router.use('/auth', authRoutes);
router.use('/user', userRoutes);
router.use('/miniprogram', miniprogramRoutes);
router.use('/articles', articleRoutes); // 新增
```

```javascript
// src/routes/api/admin/index.js (添加文章路由)
const articleRoutes = require('./article');

// 注册子路由
router.use('/auth', authRoutes);
router.use('/users', userRoutes);
router.use('/articles', articleRoutes); // 新增
```

### 🧪 Step 7: 测试编写

#### 创建文章API测试
```bash
mkdir -p tests/integration
touch tests/integration/article.test.js
```

```javascript
// tests/integration/article.test.js
const request = require('supertest');
const app = require('../../app');
const { setupTestDatabase, cleanupTestDatabase, createTestUser } = require('../helpers/database');

describe('文章API测试', () => {
  let testUser;
  let adminUser;
  let userToken;
  let adminToken;
  let testArticle;

  beforeAll(async () => {
    await setupTestDatabase();
    
    // 创建测试用户
    testUser = await createTestUser({
      username: 'article_test_user',
      email: 'article@test.com',
      password: 'test123456'
    });
    
    // 创建管理员用户
    adminUser = await createTestUser({
      username: 'article_admin',
      email: 'admin@test.com',
      password: 'admin123456',
      role: 'admin'
    });
    
    // 获取登录token
    const userLoginRes = await request(app)
      .post('/api/v1/auth/login')
      .send({
        account: 'article_test_user',
        password: 'test123456'
      });
    userToken = userLoginRes.body.data.token;
    
    const adminLoginRes = await request(app)
      .post('/api/v1/auth/login')
      .send({
        account: 'article_admin',
        password: 'admin123456'
      });
    adminToken = adminLoginRes.body.data.token;
  });

  afterAll(async () => {
    await cleanupTestDatabase();
  });

  describe('POST /api/v1/articles', () => {
    test('用户应该能够创建文章', async () => {
      const articleData = {
        title: '测试文章标题',
        content: '这是一篇测试文章的内容',
        summary: '文章摘要',
        category: 'tech',
        tags: ['测试', 'Node.js'],
        status: 'published'
      };

      const response = await request(app)
        .post('/api/v1/articles')
        .set('Authorization', `Bearer ${userToken}`)
        .send(articleData)
        .expect(201);

      expect(response.body.success).toBe(true);
      expect(response.body.data).toHaveProperty('id');
      expect(response.body.data.title).toBe(articleData.title);
      expect(response.body.data.author_id).toBe(testUser.id);
      
      testArticle = response.body.data;
    });

    test('未登录用户不能创建文章', async () => {
      const articleData = {
        title: '测试文章',
        content: '内容',
        category: 'tech'
      };

      await request(app)
        .post('/api/v1/articles')
        .send(articleData)
        .expect(401);
    });

    test('应该验证必需字段', async () => {
      const articleData = {
        title: '', // 空标题
        // 缺少content
        category: 'tech'
      };

      const response = await request(app)
        .post('/api/v1/articles')
        .set('Authorization', `Bearer ${userToken}`)
        .send(articleData)
        .expect(422);

      expect(response.body.success).toBe(false);
      expect(response.body.errors).toBeDefined();
    });
  });

  describe('GET /api/v1/articles', () => {
    test('应该返回文章列表', async () => {
      const response = await request(app)
        .get('/api/v1/articles')
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data).toBeInstanceOf(Array);
      expect(response.body.pagination).toBeDefined();
      expect(response.body.pagination).toHaveProperty('total');
      expect(response.body.pagination).toHaveProperty('page');
    });

    test('支持分页参数', async () => {
      const response = await request(app)
        .get('/api/v1/articles?page=1&limit=5')
        .expect(200);

      expect(response.body.pagination.page).toBe(1);
      expect(response.body.pagination.per_page).toBe(5);
    });

    test('支持分类筛选', async () => {
      const response = await request(app)
        .get('/api/v1/articles?category=tech')
        .expect(200);

      expect(response.body.success).toBe(true);
    });
  });

  describe('GET /api/v1/articles/:id', () => {
    test('应该返回文章详情', async () => {
      const response = await request(app)
        .get(`/api/v1/articles/${testArticle.id}`)
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data.id).toBe(testArticle.id);
      expect(response.body.data.title).toBe(testArticle.title);
      expect(response.body.data.author).toBeDefined();
    });

    test('不存在的文章应该返回404', async () => {
      await request(app)
        .get('/api/v1/articles/99999')
        .expect(404);
    });
  });

  describe('PUT /api/v1/articles/:id', () => {
    test('作者应该能够更新自己的文章', async () => {
      const updateData = {
        title: '更新后的标题',
        summary: '更新后的摘要'
      };

      const response = await request(app)
        .put(`/api/v1/articles/${testArticle.id}`)
        .set('Authorization', `Bearer ${userToken}`)
        .send(updateData)
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data.title).toBe(updateData.title);
      expect(response.body.data.summary).toBe(updateData.summary);
    });

    test('非作者不能更新文章', async () => {
      const otherUser = await createTestUser({
        username: 'other_user',
        email: 'other@test.com',
        password: 'test123456'
      });

      const otherLoginRes = await request(app)
        .post('/api/v1/auth/login')
        .send({
          account: 'other_user',
          password: 'test123456'
        });
      const otherToken = otherLoginRes.body.data.token;

      const updateData = { title: '恶意更新' };

      await request(app)
        .put(`/api/v1/articles/${testArticle.id}`)
        .set('Authorization', `Bearer ${otherToken}`)
        .send(updateData)
        .expect(403);
    });
  });

  describe('DELETE /api/v1/articles/:id', () => {
    test('作者应该能够删除自己的文章', async () => {
      const response = await request(app)
        .delete(`/api/v1/articles/${testArticle.id}`)
        .set('Authorization', `Bearer ${userToken}`)
        .expect(200);

      expect(response.body.success).toBe(true);

      // 验证文章已被删除
      await request(app)
        .get(`/api/v1/articles/${testArticle.id}`)
        .expect(404);
    });
  });

  describe('管理员文章API', () => {
    test('管理员应该能获取文章统计', async () => {
      const response = await request(app)
        .get('/api/admin/articles/stats')
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data).toHaveProperty('total');
      expect(response.body.data).toHaveProperty('published');
      expect(response.body.data).toHaveProperty('draft');
    });

    test('普通用户不能访问管理员接口', async () => {
      await request(app)
        .get('/api/admin/articles/stats')
        .set('Authorization', `Bearer ${userToken}`)
        .expect(403);
    });
  });
});
```

#### 运行测试
```bash
# 运行文章相关测试
npm test -- tests/integration/article.test.js

# 运行所有测试
npm test
```

### 📚 Step 8: 更新文档

#### 更新API文档
```javascript
// docs/API.md (在文件中添加文章接口文档)

## 文章接口

### 获取文章列表
- **URL**: `GET /api/v1/articles`
- **描述**: 获取文章列表（分页）
- **参数**: `search`, `category`, `page`, `limit`, `sort`

### 获取文章详情
- **URL**: `GET /api/v1/articles/:id`
- **描述**: 获取指定文章详情
- **参数**: `id` - 文章ID

### 创建文章
- **URL**: `POST /api/v1/articles`
- **描述**: 创建新文章
- **认证**: 需要
- **参数**:
  ```json
  {
    "title": "文章标题",
    "content": "文章内容",
    "summary": "文章摘要",
    "category": "文章分类",
    "tags": ["标签1", "标签2"],
    "status": "published"
  }
  ```

### 更新文章
- **URL**: `PUT /api/v1/articles/:id`
- **描述**: 更新文章信息
- **认证**: 需要（作者或管理员）

### 删除文章
- **URL**: `DELETE /api/v1/articles/:id`
- **描述**: 删除文章
- **认证**: 需要（作者或管理员）

### 搜索文章
- **URL**: `GET /api/v1/articles/search`
- **描述**: 搜索文章
- **参数**: `keyword`, `limit`

### 点赞文章
- **URL**: `POST /api/v1/articles/:id/like`
- **描述**: 为文章点赞
- **认证**: 需要

## 管理员文章接口

### 获取文章统计
- **URL**: `GET /api/admin/articles/stats`
- **描述**: 获取文章统计信息
- **权限**: 管理员

### 管理文章列表
- **URL**: `GET /api/admin/articles`
- **描述**: 获取所有文章列表（包括草稿）
- **权限**: 管理员
```

### 📋 Step 9: 记录修改日志

```bash
echo "

## $(date '+%Y-%m-%d') 文章管理功能开发

### 新增功能
完整的文章管理系统，包括：

#### 1. 数据模型
- **文章模型** - \`src/models/Article.js\`
- **用户文章关联关系** - 一对多关系
- **数据库迁移** - 自动创建articles表

#### 2. 业务逻辑层
- **文章服务** - \`src/services/articleService.js\`
- **完整CRUD操作** - 创建、读取、更新、删除
- **搜索功能** - 标题、摘要、内容搜索
- **统计功能** - 文章数量、分类统计
- **权限控制** - 作者权限验证

#### 3. API接口
- **小程序端API** - \`/api/v1/articles/*\`
- **管理员API** - \`/api/admin/articles/*\`
- **数据验证** - 完整的输入验证规则
- **错误处理** - 统一错误响应格式

#### 4. 测试用例
- **集成测试** - \`tests/integration/article.test.js\`
- **API测试** - 完整的CRUD操作测试
- **权限测试** - 用户权限和管理员权限测试
- **边界测试** - 异常情况和错误处理测试

### 主要API接口

#### 小程序端API
- \`GET /api/v1/articles\` - 获取文章列表
- \`GET /api/v1/articles/:id\` - 获取文章详情
- \`POST /api/v1/articles\` - 创建文章
- \`PUT /api/v1/articles/:id\` - 更新文章
- \`DELETE /api/v1/articles/:id\` - 删除文章
- \`GET /api/v1/articles/search\` - 搜索文章
- \`POST /api/v1/articles/:id/like\` - 点赞文章

#### 管理员API
- \`GET /api/admin/articles\` - 获取所有文章
- \`GET /api/admin/articles/stats\` - 文章统计
- \`PUT /api/admin/articles/:id\` - 管理员更新文章
- \`DELETE /api/admin/articles/:id\` - 管理员删除文章

### 新增的文件
1. \`src/models/Article.js\` - 文章数据模型
2. \`src/services/articleService.js\` - 文章业务逻辑
3. \`src/controllers/article.js\` - 文章控制器
4. \`src/routes/api/v1/article.js\` - 小程序端文章路由
5. \`src/routes/api/admin/article.js\` - 管理员文章路由
6. \`tests/integration/article.test.js\` - 文章API测试

### 修改的文件
1. \`src/utils/validate.js\` - 添加文章验证规则
2. \`src/database/migrate.js\` - 添加文章模型导入
3. \`src/routes/api/v1/index.js\` - 注册文章路由
4. \`src/routes/api/admin/index.js\` - 注册管理员文章路由
5. \`docs/API.md\` - 更新API文档

### 技术特点
- **分层架构**: 清晰的MVC分层，易于维护和扩展
- **权限控制**: 基于角色的访问控制，保证数据安全
- **数据验证**: 完整的输入验证，防止无效数据
- **错误处理**: 统一的错误处理机制，用户友好的错误信息
- **测试覆盖**: 完整的API测试，保证功能稳定性
- **文档齐全**: 详细的API文档，便于前端开发对接

### 扩展建议
1. **文章分类管理**: 可以开发独立的分类管理功能
2. **文章评论**: 添加文章评论系统
3. **文章收藏**: 用户文章收藏功能
4. **文章审核**: 文章发布审核流程
5. **富文本编辑**: 支持富文本内容和图片上传

" >> log.md
```

---

## 最佳实践

### 🏗️ 架构设计原则

#### 1. 分层架构
```
展示层 (Routes)
    ↓
控制层 (Controllers)
    ↓
业务层 (Services)
    ↓
数据层 (Models)
    ↓
数据库 (MySQL)
```

#### 2. 单一职责原则
- **Controllers**: 只处理HTTP请求响应
- **Services**: 只处理业务逻辑
- **Models**: 只定义数据结构和关系
- **Utils**: 只提供通用工具函数

#### 3. 依赖注入
```javascript
// 好的做法
class UserService {
  constructor(userModel, logger) {
    this.userModel = userModel;
    this.logger = logger;
  }
}

// 避免直接依赖
class UserService {
  createUser() {
    const User = require('../models/User'); // 避免
  }
}
```

### 🔐 安全最佳实践

#### 1. 输入验证
```javascript
// 使用express-validator进行数据验证
const validation = [
  body('email').isEmail().normalizeEmail(),
  body('password').isLength({ min: 6 }).escape(),
  handleValidationErrors
];
```

#### 2. SQL注入防护
```javascript
// 使用Sequelize参数化查询
User.findAll({
  where: {
    username: req.body.username // 自动防护
  }
});

// 避免原生SQL拼接
const sql = `SELECT * FROM users WHERE username = '${username}'`; // 危险
```

#### 3. 认证授权
```javascript
// 分层权限控制
router.use(authenticateToken);      // 认证
router.use(requireRole('admin'));   // 授权
router.use(requireOwnership());     // 资源所有权
```

### 📊 数据库设计原则

#### 1. 命名规范
```javascript
// 表名：复数形式，下划线命名
tableName: 'user_profiles'

// 字段名：下划线命名
field_name: 'created_at'

// 外键：表名_id
foreign_key: 'user_id'
```

#### 2. 索引优化
```javascript
// 为经常查询的字段添加索引
indexes: [
  { name: 'idx_email', fields: ['email'] },
  { name: 'idx_status', fields: ['status'] },
  { name: 'idx_created_at', fields: ['created_at'] }
]
```

#### 3. 数据类型选择
```javascript
// 合适的数据类型
id: DataTypes.INTEGER,              // 主键用INTEGER
status: DataTypes.ENUM(...),        // 状态用ENUM
content: DataTypes.TEXT('long'),    // 长文本用TEXT
created_at: DataTypes.DATE          // 时间用DATE
```

### 📝 代码规范

#### 1. 命名规范
```javascript
// 文件命名：小驼峰命名
userService.js
authController.js

// 类命名：大驼峰命名
class UserService {}
class AuthController {}

// 变量命名：小驼峰命名
const userId = 1;
const userName = 'test';

// 常量命名：大写下划线
const MAX_RETRY_COUNT = 3;
const API_VERSION = 'v1';
```

#### 2. 函数设计
```javascript
// 单一职责
function calculateTax(amount) {
  return amount * 0.1;
}

// 纯函数（无副作用）
function formatDate(date, format) {
  // 不修改输入参数
  return moment(date).format(format);
}

// 错误处理
async function getUserById(id) {
  if (!id) {
    throw new Error('用户ID不能为空');
  }
  
  const user = await User.findByPk(id);
  if (!user) {
    throw new Error('用户不存在');
  }
  
  return user;
}
```

#### 3. 注释规范
```javascript
/**
 * 用户登录服务
 * @param {string} account - 账户（用户名/邮箱/手机号）
 * @param {string} password - 密码
 * @param {Object} req - Express请求对象
 * @returns {Promise<Object>} 登录结果
 * @throws {Error} 登录失败时抛出错误
 */
async function login(account, password, req) {
  // 实现代码...
}
```

### 🧪 测试策略

#### 1. 测试金字塔
```
         E2E Tests (端到端测试)
              ↑ 少量
      ────────────────────
    Integration Tests (集成测试) 
            ↑ 适量
  ──────────────────────────────
Unit Tests (单元测试)
      ↑ 大量
```

#### 2. 测试覆盖率目标
- **单元测试**: 90%+ 覆盖率
- **集成测试**: 关键业务流程100%覆盖
- **E2E测试**: 主要用户场景覆盖

#### 3. 测试编写原则
```javascript
// AAA模式：Arrange, Act, Assert
describe('用户服务测试', () => {
  test('应该能够创建用户', async () => {
    // Arrange - 准备测试数据
    const userData = {
      username: 'testuser',
      email: 'test@example.com',
      password: 'password123'
    };
    
    // Act - 执行操作
    const user = await userService.createUser(userData);
    
    // Assert - 验证结果
    expect(user.id).toBeDefined();
    expect(user.username).toBe(userData.username);
    expect(user.password).not.toBe(userData.password); // 应该被加密
  });
});
```

### 📊 性能优化

#### 1. 数据库优化
```javascript
// 使用索引
const users = await User.findAll({
  where: { status: 'active' }, // status字段有索引
  order: [['created_at', 'DESC']] // created_at有索引
});

// 选择必要字段
const users = await User.findAll({
  attributes: ['id', 'username', 'email'], // 只选择需要的字段
  limit: 20 // 限制返回数量
});

// 预加载关联数据
const articles = await Article.findAll({
  include: [{
    model: User,
    as: 'author',
    attributes: ['id', 'username'] // 只加载需要的字段
  }]
});
```

#### 2. 缓存策略
```javascript
// Redis缓存示例
const cache = require('redis').createClient();

async function getUserFromCache(userId) {
  const cacheKey = `user:${userId}`;
  const cached = await cache.get(cacheKey);
  
  if (cached) {
    return JSON.parse(cached);
  }
  
  const user = await User.findByPk(userId);
  await cache.setex(cacheKey, 3600, JSON.stringify(user)); // 缓存1小时
  
  return user;
}
```

#### 3. 分页优化
```javascript
// 游标分页（推荐用于大数据量）
async function getArticlesByCursor(cursor, limit = 20) {
  const whereCondition = cursor ? {
    id: { [Op.lt]: cursor } // 使用主键作为游标
  } : {};
  
  return Article.findAll({
    where: whereCondition,
    limit,
    order: [['id', 'DESC']]
  });
}
```

---

## 部署指南

### 🏭 生产环境部署

#### 1. 服务器环境准备
```bash
# CentOS/RHEL
sudo yum update -y
sudo yum install -y nodejs npm mysql-server nginx

# Ubuntu/Debian
sudo apt update
sudo apt install -y nodejs npm mysql-server nginx

# 使用 Node.js 版本管理工具
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
nvm install 18
nvm use 18
```

#### 2. 应用部署配置
```bash
# 创建应用目录
sudo mkdir -p /var/www/api-scaffold
sudo chown $USER:$USER /var/www/api-scaffold
cd /var/www/api-scaffold

# 克隆代码
git clone <your-repo-url> .

# 安装依赖（生产环境）
npm ci --only=production

# 配置环境变量
cp .env.example .env
vim .env # 配置生产环境变量
```

#### 3. 生产环境变量配置
```env
# 生产环境配置示例
NODE_ENV=production
PORT=3000

# 数据库配置
DB_HOST=localhost
DB_PORT=3306
DB_NAME=scaffold_prod
DB_USER=api_user
DB_PASSWORD=strong_password_here

# JWT密钥（必须是强密钥）
JWT_SECRET=your_very_secure_jwt_secret_at_least_32_characters_long
JWT_EXPIRES_IN=7d
JWT_REFRESH_EXPIRES_IN=30d

# 文件上传
UPLOAD_DIR=/var/www/uploads
MAX_FILE_SIZE=10MB

# 日志配置
LOG_LEVEL=info
LOG_MAX_SIZE=20m
LOG_MAX_FILES=14d
```

#### 4. MySQL 数据库配置
```sql
-- 创建生产数据库和用户
CREATE DATABASE scaffold_prod CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
CREATE USER 'api_user'@'localhost' IDENTIFIED BY 'strong_password_here';
GRANT ALL PRIVILEGES ON scaffold_prod.* TO 'api_user'@'localhost';
FLUSH PRIVILEGES;
```

#### 5. PM2 进程管理
```bash
# 安装PM2
npm install -g pm2

# 创建PM2配置文件
cat > ecosystem.config.js << EOF
module.exports = {
  apps: [{
    name: 'api-scaffold',
    script: 'app.js',
    instances: 'max',
    exec_mode: 'cluster',
    env: {
      NODE_ENV: 'production',
      PORT: 3000
    },
    error_file: './logs/pm2-error.log',
    out_file: './logs/pm2-out.log',
    log_file: './logs/pm2-combined.log',
    time: true,
    max_memory_restart: '1G'
  }]
};
EOF

# 启动应用
pm2 start ecosystem.config.js
pm2 save
pm2 startup
```

#### 6. Nginx 反向代理配置
```nginx
# /etc/nginx/sites-available/api-scaffold
server {
    listen 80;
    server_name yourdomain.com;
    
    # 重定向到HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name yourdomain.com;
    
    # SSL证书配置
    ssl_certificate /path/to/certificate.crt;
    ssl_certificate_key /path/to/private.key;
    
    # SSL配置
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;
    ssl_prefer_server_ciphers off;
    
    # 请求体大小限制
    client_max_body_size 10M;
    
    # API代理
    location / {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }
    
    # 静态文件直接服务
    location /uploads/ {
        alias /var/www/uploads/;
        expires 30d;
        add_header Cache-Control "public, no-transform";
    }
    
    # 安全头
    add_header X-Content-Type-Options nosniff;
    add_header X-Frame-Options DENY;
    add_header X-XSS-Protection "1; mode=block";
}
```

#### 7. SSL证书配置
```bash
# 使用Let's Encrypt免费证书
sudo apt install certbot python3-certbot-nginx
sudo certbot --nginx -d yourdomain.com

# 自动续期
sudo crontab -e
# 添加：0 12 * * * /usr/bin/certbot renew --quiet
```

### 🐳 Docker 部署

#### 1. Dockerfile
```dockerfile
FROM node:18-alpine

# 设置工作目录
WORKDIR /app

# 复制package文件
COPY package*.json ./

# 安装依赖
RUN npm ci --only=production && npm cache clean --force

# 复制应用代码
COPY . .

# 创建非root用户
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001

# 更改所有权
RUN chown -R nodejs:nodejs /app
USER nodejs

# 暴露端口
EXPOSE 3000

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

# 启动应用
CMD ["node", "app.js"]
```

#### 2. docker-compose.yml
```yaml
version: '3.8'

services:
  app:
    build: .
    container_name: api-scaffold
    restart: unless-stopped
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DB_HOST=mysql
      - DB_USER=api_user
      - DB_PASSWORD=strong_password
      - DB_NAME=scaffold_db
    depends_on:
      - mysql
      - redis
    volumes:
      - uploads:/app/uploads
      - logs:/app/logs
    networks:
      - app-network

  mysql:
    image: mysql:8.0
    container_name: api-mysql
    restart: unless-stopped
    environment:
      - MYSQL_ROOT_PASSWORD=root_password
      - MYSQL_DATABASE=scaffold_db
      - MYSQL_USER=api_user
      - MYSQL_PASSWORD=strong_password
    volumes:
      - mysql_data:/var/lib/mysql
    networks:
      - app-network

  redis:
    image: redis:7-alpine
    container_name: api-redis
    restart: unless-stopped
    networks:
      - app-network

  nginx:
    image: nginx:alpine
    container_name: api-nginx
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - uploads:/var/www/uploads
    depends_on:
      - app
    networks:
      - app-network

volumes:
  mysql_data:
  uploads:
  logs:

networks:
  app-network:
    driver: bridge
```

#### 3. Docker部署命令
```bash
# 构建并启动服务
docker-compose up -d

# 查看日志
docker-compose logs -f app

# 进入容器
docker-compose exec app sh

# 停止服务
docker-compose down

# 更新部署
docker-compose pull
docker-compose up -d --force-recreate
```

### 🔄 CI/CD 自动化部署

#### 1. GitHub Actions 配置
```yaml
# .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run tests
      run: npm test
      env:
        NODE_ENV: test

  deploy:
    needs: test
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Deploy to server
      uses: appleboy/ssh-action@v0.1.5
      with:
        host: ${{ secrets.HOST }}
        username: ${{ secrets.USERNAME }}
        key: ${{ secrets.PRIVATE_KEY }}
        script: |
          cd /var/www/api-scaffold
          git pull origin main
          npm ci --only=production
          npm run migrate
          pm2 reload ecosystem.config.js
```

### 📊 监控和日志

#### 1. 应用监控
```javascript
// 性能监控中间件
function performanceMonitor(req, res, next) {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    
    // 记录慢请求
    if (duration > 1000) {
      logger.warn('Slow request detected', {
        method: req.method,
        url: req.url,
        duration,
        userAgent: req.headers['user-agent']
      });
    }
    
    // 记录错误响应
    if (res.statusCode >= 400) {
      logger.error('Error response', {
        method: req.method,
        url: req.url,
        statusCode: res.statusCode,
        duration
      });
    }
  });
  
  next();
}
```

#### 2. 日志聚合
```bash
# 使用rsyslog收集日志
sudo vim /etc/rsyslog.d/50-api-scaffold.conf

# 添加配置
$ModLoad imfile
$InputFileName /var/www/api-scaffold/logs/combined.log
$InputFileTag api-scaffold:
$InputFileStateFile stat-api-scaffold
$InputFileSeverity info
$InputFileFacility local7
$InputRunFileMonitor

# 重启rsyslog
sudo systemctl restart rsyslog
```

#### 3. 健康检查脚本
```bash
#!/bin/bash
# health-check.sh

API_URL="https://yourdomain.com/health"
TIMEOUT=10

response=$(curl -s -w "%{http_code}" --connect-timeout $TIMEOUT $API_URL)
http_code="${response: -3}"

if [ "$http_code" != "200" ]; then
    echo "API health check failed with code: $http_code"
    # 发送告警通知
    curl -X POST https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK \
         -H 'Content-type: application/json' \
         --data '{"text":"API服务异常，HTTP状态码: '$http_code'"}'
    exit 1
fi

echo "API health check passed"
exit 0
```

---

## 常见问题

### ❓ 开发问题

#### Q1: 数据库连接失败
**问题**: `SequelizeConnectionError: Access denied for user 'root'@'localhost'`

**解决方案**:
1. 检查 `.env` 文件中的数据库配置
2. 确认MySQL服务已启动
3. 验证数据库用户名和密码
4. 检查防火墙设置

```bash
# 测试数据库连接
mysql -h localhost -u root -p

# 检查MySQL服务状态
sudo systemctl status mysql
```

#### Q2: JWT Token验证失败
**问题**: `JsonWebTokenError: invalid signature`

**解决方案**:
1. 确保 `JWT_SECRET` 在所有环境中一致
2. 检查token是否被正确传递
3. 验证token格式是否正确

```javascript
// 调试token
console.log('Token:', req.headers.authorization);
console.log('JWT_SECRET:', process.env.JWT_SECRET);
```

#### Q3: 权限验证问题
**问题**: 用户有权限但接口返回403

**解决方案**:
1. 检查用户角色是否正确设置
2. 验证权限等级配置
3. 确认路由中间件的执行顺序

```javascript
// 调试权限
console.log('User role:', req.user.role);
console.log('Required roles:', allowedRoles);
console.log('User level:', authConfig.roleHierarchy[req.user.role]);
```

#### Q4: 文件上传失败
**问题**: 文件上传时出现错误

**解决方案**:
1. 检查上传目录权限
2. 确认文件大小限制
3. 验证文件类型是否允许

```bash
# 设置上传目录权限
chmod 755 uploads/
chown -R www-data:www-data uploads/
```

### 🚀 性能问题

#### Q5: API响应慢
**问题**: 接口响应时间超过预期

**解决方案**:
1. 添加数据库索引
2. 优化SQL查询
3. 使用分页限制数据量
4. 实现缓存机制

```javascript
// 性能分析
console.time('query');
const result = await User.findAll();
console.timeEnd('query');
```

#### Q6: 内存占用过高
**问题**: Node.js进程内存持续增长

**解决方案**:
1. 检查内存泄漏
2. 优化数据处理逻辑
3. 使用流处理大文件
4. 配置垃圾回收

```bash
# 监控内存使用
node --inspect app.js
# 在Chrome中打开 chrome://inspect 调试
```

### 🔒 安全问题

#### Q7: 跨域请求被阻止
**问题**: CORS错误

**解决方案**:
1. 检查CORS配置
2. 确认请求来源域名
3. 验证预检请求处理

```javascript
// 调试CORS
app.use(cors({
  origin: function (origin, callback) {
    console.log('Request origin:', origin);
    callback(null, true);
  }
}));
```

#### Q8: SQL注入风险
**问题**: 数据库查询安全性

**解决方案**:
1. 使用Sequelize参数化查询
2. 避免拼接SQL语句
3. 验证用户输入

```javascript
// 安全查询
const users = await User.findAll({
  where: { username: userInput } // 自动转义
});

// 避免的做法
const sql = `SELECT * FROM users WHERE username = '${userInput}'`;
```

### 📚 扩展问题

#### Q9: 如何添加新的认证方式?
**解决方案**:
1. 在 `authService.js` 中添加新的认证函数
2. 创建对应的路由和控制器
3. 更新认证中间件
4. 添加相应的测试用例

#### Q10: 如何实现数据库读写分离?
**解决方案**:
```javascript
// 配置主从数据库
const sequelize = new Sequelize({
  replication: {
    read: [
      { host: 'slave1.db.com', username: 'read_user', password: 'pass' },
      { host: 'slave2.db.com', username: 'read_user', password: 'pass' }
    ],
    write: { host: 'master.db.com', username: 'write_user', password: 'pass' }
  }
});
```

#### Q11: 如何实现分布式缓存?
**解决方案**:
```javascript
// Redis集群配置
const Redis = require('ioredis');
const cluster = new Redis.Cluster([
  { port: 6380, host: '127.0.0.1' },
  { port: 6381, host: '127.0.0.1' },
  { port: 6382, host: '127.0.0.1' }
]);
```

---

## 📚 学习资源

### 📖 推荐文档
- [Express.js 官方文档](https://expressjs.com/)
- [Sequelize ORM 文档](https://sequelize.org/)
- [Jest 测试框架](https://jestjs.io/)
- [Node.js 最佳实践](https://github.com/goldbergyoni/nodebestpractices)

### 🎓 进阶学习
- [微服务架构设计](https://microservices.io/)
- [Redis 缓存策略](https://redis.io/docs/)
- [Docker 容器化](https://docs.docker.com/)
- [Kubernetes 编排](https://kubernetes.io/)

### 🛠️ 有用工具
- [Postman](https://www.postman.com/) - API测试
- [MySQL Workbench](https://www.mysql.com/products/workbench/) - 数据库管理
- [PM2](https://pm2.keymetrics.io/) - 进程管理
- [Winston](https://github.com/winstonjs/winston) - 日志系统

---

## 🎯 总结

这个 **Backend API Scaffold Framework** 提供了一个完整、可扩展的后端API开发框架，具有以下优势：

### ✨ 核心价值
- **🚀 快速开发**: 完整的基础功能，开箱即用
- **🔒 安全可靠**: 完善的认证、权限、数据验证
- **📱 双端支持**: 同时服务小程序端和管理端
- **🧪 测试完备**: 全面的测试框架和用例
- **📚 文档齐全**: 详细的开发和部署指南
- **🏗️ 架构清晰**: 分层设计，易于维护和扩展

### 🎖️ 适用场景
- 小程序项目后端开发
- 管理后台系统
- 移动APP后端服务
- 中小型Web应用
- 快速原型开发
- 学习现代Node.js开发

### 🔧 技术特点
- **现代技术栈**: Node.js + Express + MySQL + Sequelize
- **微服务友好**: 清晰的模块化设计
- **云原生就绪**: 支持Docker和Kubernetes部署
- **性能优化**: 内置缓存、索引、分页等优化
- **监控完善**: 日志、性能监控、健康检查

### 🚀 扩展方向
基于这个框架，你可以继续扩展：
- 消息队列系统
- 文件存储服务
- 实时通信功能
- 数据分析模块
- 第三方服务集成

希望这份详细的指南能够帮助你快速掌握框架的使用，并成功开发出高质量的API服务！

---

**💡 提示**: 如果在使用过程中遇到问题，请参考"常见问题"部分，或者查看项目的测试用例来了解最佳实践。

**📧 支持**: 欢迎提交Issue和Pull Request来改进这个框架！